<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>UVM-ML: Bp::BpInterconnect Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li id="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="namespaceBp.html">Bp</a>::<a class="el" href="classBp_1_1BpInterconnect.html">BpInterconnect</a></div>
<h1>Bp::BpInterconnect Class Reference</h1><!-- doxytag: class="Bp::BpInterconnect" -->Enclosure class for backplane interface and global state.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="bp__interconnect_8h-source.html">bp_interconnect.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74d122a0d7b2c6ea16881d74c4759a23"></a><!-- doxytag: member="Bp::BpInterconnect::legal_abbreviation_lengths_type" ref="74d122a0d7b2c6ea16881d74c4759a23" args="" -->
typedef vector&lt; set&lt; unsigned <br>
char &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#74d122a0d7b2c6ea16881d74c4759a23">legal_abbreviation_lengths_type</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb7e2c206a2e2a7841a89d22bf2469a277f96cab4411cea445ce09add01788e9"></a><!-- doxytag: member="Bp::BpInterconnect::UVM_ML_UNRECOGNIZED_COMMAND" ref="bb7e2c206a2e2a7841a89d22bf2469a277f96cab4411cea445ce09add01788e9" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>UVM_ML_UNRECOGNIZED_COMMAND</b> = -1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb7e2c206a2e2a7841a89d22bf2469a2ab1d07c19d12933c8b3dbac68f2af446"></a><!-- doxytag: member="Bp::BpInterconnect::UVM_ML_COMMAND_FAILURE" ref="bb7e2c206a2e2a7841a89d22bf2469a2ab1d07c19d12933c8b3dbac68f2af446" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>UVM_ML_COMMAND_FAILURE</b> = 0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bb7e2c206a2e2a7841a89d22bf2469a23a7983229a5fdf9d2091aeaad2f4adf0"></a><!-- doxytag: member="Bp::BpInterconnect::UVM_ML_COMMAND_SUCCESS" ref="bb7e2c206a2e2a7841a89d22bf2469a23a7983229a5fdf9d2091aeaad2f4adf0" args="" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>UVM_ML_COMMAND_SUCCESS</b> = 1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#bb7e2c206a2e2a7841a89d22bf2469a2">exec_status</a> { <b>UVM_ML_UNRECOGNIZED_COMMAND</b> = -1, 
<b>UVM_ML_COMMAND_FAILURE</b> = 0, 
<b>UVM_ML_COMMAND_SUCCESS</b> = 1
 }</td></tr>

<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bp_api_struct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#bfa65d55a25db03108e3bf13d91a5a15">GetProvidedTray</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns tray of Backplane provider API function pointers.  <a href="#bfa65d55a25db03108e3bf13d91a5a15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#a7393c82ea705f1d1bf9f56a92dde722">SetTraceMode</a> (int mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turn tracing on/off.  <a href="#a7393c82ea705f1d1bf9f56a92dde722"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#09f290296954e68459115db1cbb152da">RegisterFramework</a> (const string &amp;frameworkName, vector&lt; string &gt; &amp;frameworkIndicators, bp_frmw_c_api_struct *requiredApi)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register a framework with the backplane.  <a href="#09f290296954e68459115db1cbb152da"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#5442d2afe6ba570957a6a768da4c36ea">ProcessTopsAndTests</a> (vector&lt; string &gt; &amp;tops, vector&lt; string &gt; &amp;tests)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Process vector of strings that denotes top components/tests in TB.  <a href="#5442d2afe6ba570957a6a768da4c36ea"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#86e816f5e8f45946215871bebcf11256">AddRootNode</a> (int frameworkId, int topComponentId, const string &amp;compIdentifier, const string &amp;instanceName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows a framework to add a root node descriptor procedurally.  <a href="#86e816f5e8f45946215871bebcf11256"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#eb4a0bd3c8555ea95b426a01af9ce7c6">RegisterRoute</a> (int frameworkId, const string &amp;producerPath, const string &amp;providerPath)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shall be invoked by a framework to connect ML TLM ports or sockets.  <a href="#eb4a0bd3c8555ea95b426a01af9ce7c6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#9353d623ea0069e26179ef927dfac4b8">NotifyPhase</a> (unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies the framework of a non-runtime phase (non-time consuming).  <a href="#9353d623ea0069e26179ef927dfac4b8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#bcf6757f3ee45264aa241df3f579e592">TransmitPhase</a> (unsigned int frameworkId, const string &amp;targetFrmwInd, int targetId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies a target component of a non_runtime phase (non-time conssuming).  <a href="#bcf6757f3ee45264aa241df3f579e592"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#c1607df6b1ea36d19b27ca0533a661ae">NotifyRuntimePhase</a> (unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction, uvm_ml_time_unit timeUnit, double timeValue, unsigned int *participate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies the execution of a runtime phase. A phase that consumes time.  <a href="#c1607df6b1ea36d19b27ca0533a661ae"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#0600b8bfdffd679657d4e2600b51edb4">NotifyPhaseDone</a> (unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notifies the phase master that the framework is ready to exit the phase.  <a href="#0600b8bfdffd679657d4e2600b51edb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#6f42da9e97f65de3ac34b45b84416103">PhaseSrvNotifyPhaseDone</a> (unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the phase service provider to notify the framework is ready.  <a href="#6f42da9e97f65de3ac34b45b84416103"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#8c3ea0928b653830d2457db4d43b3443">PhaseSrvCheckPhase</a> (const char *phaseName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the phase service provider to check phase name.  <a href="#8c3ea0928b653830d2457db4d43b3443"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#16e05da4e59f41d1cfd68bcd1d5aafdb">PhaseSrvCheckFuturePhase</a> (const char *phaseName, uvm_ml_phase_action phaseAction)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the phase service provider to check phase did not pass.  <a href="#16e05da4e59f41d1cfd68bcd1d5aafdb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e2f7e9a88834c73e1fc54a287c0d91c8"></a><!-- doxytag: member="Bp::BpInterconnect::StartPhasing" ref="e2f7e9a88834c73e1fc54a287c0d91c8" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#e2f7e9a88834c73e1fc54a287c0d91c8">StartPhasing</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calls the sevice provider to start phasing the ML TB. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#6ab9c0993afbbb612d29976b8ad78dcc">RegisterCommonSrvFrmw</a> (FrameworkProxyClass *frmw)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register common service framework with backplane.  <a href="#6ab9c0993afbbb612d29976b8ad78dcc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#b80b1f86d35fdf32d002e0efa074e9d7">RegisterSrvProviders</a> (unsigned int frameworkId, bp_srv_provider_struct *srvProviders)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register service providers with the backplane.  <a href="#b80b1f86d35fdf32d002e0efa074e9d7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#a55e8faa9b6907f92b1d863a2e1b2fb3">GetVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the UVM-ML version.  <a href="#a55e8faa9b6907f92b1d863a2e1b2fb3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c0cbc6f7b1bb06808c5f76b42b00478"></a><!-- doxytag: member="Bp::BpInterconnect::print_format_va_list" ref="9c0cbc6f7b1bb06808c5f76b42b00478" args="(int level, const char *caller_name, const char *fstring, va_list &amp;args)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>print_format_va_list</b> (int level, const char *caller_name, const char *fstring, va_list &amp;args)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#f21b84dfffaa4bfe9f265ded28cc3027">NbPut</a> (int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking put interface method.  <a href="#f21b84dfffaa4bfe9f265ded28cc3027"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#d0bca5a8412b9d6467113b0e72f9a847">CanPut</a> (int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking put interface method.  <a href="#d0bca5a8412b9d6467113b0e72f9a847"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#1e084631ca45d91e9d9ed972338dc1d6">NbGet</a> (int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking get interface method.  <a href="#1e084631ca45d91e9d9ed972338dc1d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#0f06f00ddfd0bdd3c96556fdd5cb76f1">CanGet</a> (int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking get interface method.  <a href="#0f06f00ddfd0bdd3c96556fdd5cb76f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#3880f3b289d789e2721e3ddc95303e37">NbPeek</a> (int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking peek interface method.  <a href="#3880f3b289d789e2721e3ddc95303e37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#330f230f504756c5353be3a88501b660">CanPeek</a> (int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 non-blocking peek interface method.  <a href="#330f230f504756c5353be3a88501b660"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#2060b6637b885cfea3d9bc0f78664fa3">Write</a> (int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM analysis interface method.  <a href="#2060b6637b885cfea3d9bc0f78664fa3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#710d0f12abd91a767dd8dc5cfa9eb8ac">Put</a> (int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 blocking put interface method.  <a href="#710d0f12abd91a767dd8dc5cfa9eb8ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#b86bb5db30aa4fe4e1011bce9b7c067f">RequestPut</a> (int frameworkId, int producerBindKey, int requestId, unsigned int streamSize, uvm_ml_stream_t stream, bool &amp;done, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM! blocking put interface pseudo method.  <a href="#b86bb5db30aa4fe4e1011bce9b7c067f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#87f86ef3d44ae44ee5c38a8467b85eb8">Get</a> (int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM1 blocking get interface method.  <a href="#87f86ef3d44ae44ee5c38a8467b85eb8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#47b37a8d9b90c62b180fbf780297db0d">RequestGet</a> (int frameworkId, int producerBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t stream, bool &amp;done, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Part of the pseudo-blocking mechanism for implementation of the TLM1 blocking.  <a href="#47b37a8d9b90c62b180fbf780297db0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#d1dffcc4594cea347254159a5746f651">GetRequested</a> (int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Part of the pseudo-blocking mechanism for implementation of the TLM1 blocking.  <a href="#d1dffcc4594cea347254159a5746f651"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="561731917bdf8a7192a6c17235e9d491"></a><!-- doxytag: member="Bp::BpInterconnect::Peek" ref="561731917bdf8a7192a6c17235e9d491" args="(int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#561731917bdf8a7192a6c17235e9d491">Peek</a> (int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Native blocking call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bba52de46b9cf029cad15db3a6279246"></a><!-- doxytag: member="Bp::BpInterconnect::RequestPeek" ref="bba52de46b9cf029cad15db3a6279246" args="(int frameworkId, int producerBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t stream, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#bba52de46b9cf029cad15db3a6279246">RequestPeek</a> (int frameworkId, int producerBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t stream, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-spawning blocking call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="facfb0f35f0393da5b4b910d3a61ed8b"></a><!-- doxytag: member="Bp::BpInterconnect::PeekRequested" ref="facfb0f35f0393da5b4b910d3a61ed8b" args="(int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t stream)" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#facfb0f35f0393da5b4b910d3a61ed8b">PeekRequested</a> (int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawned blocking call completion. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2100cb04a4824d57288e1832192a354d"></a><!-- doxytag: member="Bp::BpInterconnect::TransportTLM1" ref="2100cb04a4824d57288e1832192a354d" args="(int frameworkId, int producerBindKey, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t &amp;respStream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#2100cb04a4824d57288e1832192a354d">TransportTLM1</a> (int frameworkId, int producerBindKey, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t &amp;respStream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Native blocking call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="bdfc8883a6e5582ffd55fe46b79c19fa"></a><!-- doxytag: member="Bp::BpInterconnect::RequestTransportTLM1" ref="bdfc8883a6e5582ffd55fe46b79c19fa" args="(int frameworkId, int producerBindKey, int requestId, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t &amp;respStream, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#bdfc8883a6e5582ffd55fe46b79c19fa">RequestTransportTLM1</a> (int frameworkId, int producerBindKey, int requestId, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t &amp;respStream, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-spawning blocking call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#3227dbbb0974eb699a49f89ba3820529">TransportTLM1Response</a> (int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t &amp;respStream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawned blocking call completion.  <a href="#3227dbbb0974eb699a49f89ba3820529"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="eda1d00df871ce56199190810d713de6"></a><!-- doxytag: member="Bp::BpInterconnect::NbTransportTLM1" ref="eda1d00df871ce56199190810d713de6" args="(int frameworkId, int producerBindKey, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t respStream, uvm_ml_time_unit timeUnit, double timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>NbTransportTLM1</b> (int frameworkId, int producerBindKey, unsigned int reqStreamSize, uvm_ml_stream_t reqStream, unsigned int &amp;respStreamSize, uvm_ml_stream_t respStream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="83f4af4ff60886398cef390ff8d699ab"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyEndBlocking" ref="83f4af4ff60886398cef390ff8d699ab" args="(int frameworkId, int requestId, uvm_ml_time_unit timeUnit, double timeValue)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NotifyEndBlocking</b> (int frameworkId, int requestId, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="637d13eb233ef5a96648accbc8be0c70"></a><!-- doxytag: member="Bp::BpInterconnect::BTransportTLM2" ref="637d13eb233ef5a96648accbc8be0c70" args="(int frameworkId, int initiatorBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time &amp;delay, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#637d13eb233ef5a96648accbc8be0c70">BTransportTLM2</a> (int frameworkId, int initiatorBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time &amp;delay, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">TLM2 blocking transport. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1801a85afa4da326e76ab0b0c30f2e0e"></a><!-- doxytag: member="Bp::BpInterconnect::RequestBTransportTLM2" ref="1801a85afa4da326e76ab0b0c30f2e0e" args="(int frameworkId, int initiatorBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time &amp;delay, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#1801a85afa4da326e76ab0b0c30f2e0e">RequestBTransportTLM2</a> (int frameworkId, int initiatorBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time &amp;delay, bool &amp;useTrueBlocking, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Thread-spawning blocking call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#4af9693692b531997648841cd5eba4a5">BTransportTLM2Response</a> (int frameworkId, int initiatorBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Spawned blocking call completion.  <a href="#4af9693692b531997648841cd5eba4a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="55eb9c188546e21eab6604c969899243"></a><!-- doxytag: member="Bp::BpInterconnect::NbTransportFwTLM2" ref="55eb9c188546e21eab6604c969899243" args="(int frameworkId, int initiatorBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_tlm_phase &amp;phase, unsigned int transactionId, uvm_ml_time &amp;delay, uvm_ml_time_unit tImeUnit, double tImeValue)" -->
static uvm_ml_tlm_sync_enum&nbsp;</td><td class="memItemRight" valign="bottom"><b>NbTransportFwTLM2</b> (int frameworkId, int initiatorBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_tlm_phase &amp;phase, unsigned int transactionId, uvm_ml_time &amp;delay, uvm_ml_time_unit tImeUnit, double tImeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="126ffbe33a5af4c6f0ffe46f11fb71bf"></a><!-- doxytag: member="Bp::BpInterconnect::NbTransportBwTLM2" ref="126ffbe33a5af4c6f0ffe46f11fb71bf" args="(int frameworkId, int targetBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_tlm_phase &amp;phase, unsigned int transactionId, uvm_ml_time &amp;delay, uvm_ml_time_unit timeUnit, double timeValue)" -->
static uvm_ml_tlm_sync_enum&nbsp;</td><td class="memItemRight" valign="bottom"><b>NbTransportBwTLM2</b> (int frameworkId, int targetBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_tlm_phase &amp;phase, unsigned int transactionId, uvm_ml_time &amp;delay, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f713c3885eeff18b2796cdd78f8299cc"></a><!-- doxytag: member="Bp::BpInterconnect::TransportDbgTLM2" ref="f713c3885eeff18b2796cdd78f8299cc" args="(int frameworkId, int targetBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>TransportDbgTLM2</b> (int frameworkId, int targetBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ddc17d1441f49fa894252e2c799bafb5"></a><!-- doxytag: member="Bp::BpInterconnect::AssignTransactionId" ref="ddc17d1441f49fa894252e2c799bafb5" args="(int frameworkId)" -->
static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><b>AssignTransactionId</b> (int frameworkId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6274816a5a0e66134886974e5792e819"></a><!-- doxytag: member="Bp::BpInterconnect::TurnOffTransactionMapping" ref="6274816a5a0e66134886974e5792e819" args="(int frameworkId, const string &amp;socketName)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>TurnOffTransactionMapping</b> (int frameworkId, const string &amp;socketName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uvm_ml_type_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#fc4b8ab12531b9a8b97c22600662d5de">GetTypeIdByTypeName</a> (int frameworkId, const string &amp;typeName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">May be used for transaction runtime type identification.  <a href="#fc4b8ab12531b9a8b97c22600662d5de"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#d5158c06f5316c53085b813f8ca55522">GetTypeNameByTypeId</a> (int frameworkId, uvm_ml_type_id_t typeId, bool GetBaseName)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">May be used by a framework if it supports passing polymorphic.  <a href="#d5158c06f5316c53085b813f8ca55522"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#20fba6aa51e5440ad3b6c8c8065d81a0">RegisterTypeMatch</a> (BpLangTypeName &amp;type1, BpLangTypeName &amp;type2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows explicit type mapping (default mapping is by the exact.  <a href="#20fba6aa51e5440ad3b6c8c8065d81a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01d7a5c6ff9af034b4682ef54bb6e88e"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyConfig" ref="01d7a5c6ff9af034b4682ef54bb6e88e" args="(int frameworkId, const char *cntxt, const char *instanceName, const char *field_name, unsigned int stream_size, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#01d7a5c6ff9af034b4682ef54bb6e88e">NotifyConfig</a> (int frameworkId, const char *cntxt, const char *instanceName, const char *field_name, unsigned int stream_size, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configuration setting call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7f8f7198c12513a8a4fd078008264c6c"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyEvent" ref="7f8f7198c12513a8a4fd078008264c6c" args="(int framework_id, const char *scope_name, const char *event_name, uvm_ml_event_notify_action action, unsigned int stream_size, uvm_ml_stream_t stream, uvm_ml_time_unit time_unit, double time_value)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#7f8f7198c12513a8a4fd078008264c6c">NotifyEvent</a> (int framework_id, const char *scope_name, const char *event_name, uvm_ml_event_notify_action action, unsigned int stream_size, uvm_ml_stream_t stream, uvm_ml_time_unit time_unit, double time_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event notification call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="53d7c9945ec7711b73ec14c9ea76aaf1"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyBarrier" ref="53d7c9945ec7711b73ec14c9ea76aaf1" args="(int framework_id, const char *scope_name, const char *barrier_name, uvm_ml_barrier_notify_action action, int count, uvm_ml_time_unit time_unit, double time_value)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#53d7c9945ec7711b73ec14c9ea76aaf1">NotifyBarrier</a> (int framework_id, const char *scope_name, const char *barrier_name, uvm_ml_barrier_notify_action action, int count, uvm_ml_time_unit time_unit, double time_value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Barrier notification call. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d0afdae8eb4f06b0e63814c5e97dd74c"></a><!-- doxytag: member="Bp::BpInterconnect::FindConnectionHandle" ref="d0afdae8eb4f06b0e63814c5e97dd74c" args="(int frameworkId, int bindKey)" -->
static <a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>FindConnectionHandle</b> (int frameworkId, int bindKey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b521c958529fafb75b9c091a6750a359"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFanoutSize" ref="b521c958529fafb75b9c091a6750a359" args="(BpConnectionHandle handle)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFanoutSize</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d9cddff87e7a9f7da77ef944a2b475dd"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFanoutHandle" ref="d9cddff87e7a9f7da77ef944a2b475dd" args="(BpConnectionHandle handle, unsigned int id)" -->
static <a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFanoutHandle</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle, unsigned int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f2e754ba281a9db3e2e4eadd148cfd58"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFaninSize" ref="f2e754ba281a9db3e2e4eadd148cfd58" args="(BpConnectionHandle handle)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFaninSize</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="01507da787b14b261706494b654d54c8"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFaninHandle" ref="01507da787b14b261706494b654d54c8" args="(BpConnectionHandle handle, unsigned int id)" -->
static <a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFaninHandle</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle, unsigned int id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="79d2213899433c3d5e22ddf702cd9680"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFrameworkName" ref="79d2213899433c3d5e22ddf702cd9680" args="(BpConnectionHandle handle)" -->
static const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFrameworkName</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="95c28d781e0282583aedfd4b60cd7108"></a><!-- doxytag: member="Bp::BpInterconnect::QueryFrameworkIndicators" ref="95c28d781e0282583aedfd4b60cd7108" args="(BpConnectionHandle handle)" -->
static const vector&lt; string &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryFrameworkIndicators</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4061bce0803a68df7d7836241b58f1de"></a><!-- doxytag: member="Bp::BpInterconnect::QueryConnectionPath" ref="4061bce0803a68df7d7836241b58f1de" args="(BpConnectionHandle handle)" -->
static const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>QueryConnectionPath</b> (<a class="el" href="namespaceBp.html#a096336b4fcdc38092b2f83f1574780b">BpConnectionHandle</a> handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60987ad737e0c76f274c56c778b3be47"></a><!-- doxytag: member="Bp::BpInterconnect::GetConnectorSize" ref="60987ad737e0c76f274c56c778b3be47" args="(int frameworkId, int producer_id)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetConnectorSize</b> (int frameworkId, int producer_id)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f694004928f81d2bd3ad783a9c0ae1f"></a><!-- doxytag: member="Bp::BpInterconnect::Synchronize" ref="8f694004928f81d2bd3ad783a9c0ae1f" args="(int frameworkId, uvm_ml_time_unit timeUnit, double timeValue)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>Synchronize</b> (int frameworkId, uvm_ml_time_unit timeUnit, double timeValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ff25720ae00acea64eae8d653e3f2dee"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterTimeCallback" ref="ff25720ae00acea64eae8d653e3f2dee" args="(int frameworkId, uvm_ml_time_unit timeUnit, double timeValue, void *cbData)" -->
static uvm_ml_handle&nbsp;</td><td class="memItemRight" valign="bottom"><b>RegisterTimeCallback</b> (int frameworkId, uvm_ml_time_unit timeUnit, double timeValue, void *cbData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1a841ecc92119b93e4983f9af381225d"></a><!-- doxytag: member="Bp::BpInterconnect::RemoveTimeCallback" ref="1a841ecc92119b93e4983f9af381225d" args="(int frameworkId, uvm_ml_handle cb_handle)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>RemoveTimeCallback</b> (int frameworkId, uvm_ml_handle cb_handle)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="024080429db8871204d2296439e384a5"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyTimeCallback" ref="024080429db8871204d2296439e384a5" args="(int frameworkId, int targetFrameworkId, uvm_ml_time_unit timeUnit, double timeValue, void *cbData)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>NotifyTimeCallback</b> (int frameworkId, int targetFrameworkId, uvm_ml_time_unit timeUnit, double timeValue, void *cbData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7776c8fea8059df8f2c45d37e3a7664b"></a><!-- doxytag: member="Bp::BpInterconnect::CreateChildJunctionNode" ref="7776c8fea8059df8f2c45d37e3a7664b" args="(int frameworkId, const string &amp;targetFrameworkIndicator, const string &amp;componentTypeName, const string &amp;instanceName, const string &amp;parentFullName, int parentJunctionNodeId)" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>CreateChildJunctionNode</b> (int frameworkId, const string &amp;targetFrameworkIndicator, const string &amp;componentTypeName, const string &amp;instanceName, const string &amp;parentFullName, int parentJunctionNodeId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e287b8e4faefd0a741abd010956ca08c"></a><!-- doxytag: member="Bp::BpInterconnect::StopPhase" ref="e287b8e4faefd0a741abd010956ca08c" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>StopPhase</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9cf72f33830ca2cd8c049dd27212bd6a"></a><!-- doxytag: member="Bp::BpInterconnect::PrintMessage" ref="9cf72f33830ca2cd8c049dd27212bd6a" args="(const string &amp;message)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PrintMessage</b> (const string &amp;message)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8c396b3ba0adb7569e89d937c4a154cf"></a><!-- doxytag: member="Bp::BpInterconnect::PrintMessage" ref="8c396b3ba0adb7569e89d937c4a154cf" args="(const char *formatString,...)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>PrintMessage</b> (const char *formatString,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bp_api_struct *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#ff112b66cfc310875bad2d0344813aee">Bootstrap</a> (vector&lt; string &gt; &amp;tops, vector&lt; string &gt; &amp;tests, bp_serror_t *serror)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke phasing.  <a href="#ff112b66cfc310875bad2d0344813aee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#fb210ebda40f9eb04d13fb72dfc9daec">Elaborate</a> (void *cbInfo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Invoke phasing.  <a href="#fb210ebda40f9eb04d13fb72dfc9daec"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#773867f3d030d254ba3d522027b512d8">PreRunCleanup</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cleanup Backplane global state.  <a href="#773867f3d030d254ba3d522027b512d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#c8730ce724663bb6f9904e87c6a1f72f">Reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset Backplane global state.  <a href="#c8730ce724663bb6f9904e87c6a1f72f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d5a78cd74503355e0383f46ff67036a"></a><!-- doxytag: member="Bp::BpInterconnect::StopRun" ref="4d5a78cd74503355e0383f46ff67036a" args="()" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>StopRun</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ec26da646af2f1998ce21e6f66740806"></a><!-- doxytag: member="Bp::BpInterconnect::AddTopLevel" ref="ec26da646af2f1998ce21e6f66740806" args="(BpTopDescriptorClass *topComponent)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddTopLevel</b> (BpTopDescriptorClass *topComponent)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ce82062aed75afc22a7b0fec67e4bf33"></a><!-- doxytag: member="Bp::BpInterconnect::GetFrameworkProxyByName" ref="ce82062aed75afc22a7b0fec67e4bf33" args="(const string &amp;frameworkName)" -->
static FrameworkProxyClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFrameworkProxyByName</b> (const string &amp;frameworkName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c99990808e1767fa70b1c84daefdf515"></a><!-- doxytag: member="Bp::BpInterconnect::GetFrameworkProxyByInd" ref="c99990808e1767fa70b1c84daefdf515" args="(const string &amp;frameworkIndicator)" -->
static FrameworkProxyClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFrameworkProxyByInd</b> (const string &amp;frameworkIndicator)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cb3681adb31429af4f5a86bab93b63d5"></a><!-- doxytag: member="Bp::BpInterconnect::GetFramework" ref="cb3681adb31429af4f5a86bab93b63d5" args="(int frameworkId)" -->
static FrameworkProxyClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetFramework</b> (int frameworkId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="817a844023c4aed445b9ee7d9c1858a7"></a><!-- doxytag: member="Bp::BpInterconnect::FindConnectionByName" ref="817a844023c4aed445b9ee7d9c1858a7" args="(const string &amp;path)" -->
static BpConnectionClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>FindConnectionByName</b> (const string &amp;path)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5acef8e0dee0b4cbfc06a685869fa39d"></a><!-- doxytag: member="Bp::BpInterconnect::AddConnection" ref="5acef8e0dee0b4cbfc06a685869fa39d" args="(const string &amp;path)" -->
static BpConnectionClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddConnection</b> (const string &amp;path)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e53d9f5d830d7c8e2074f27c6e20ebd1"></a><!-- doxytag: member="Bp::BpInterconnect::GetTraceMode" ref="e53d9f5d830d7c8e2074f27c6e20ebd1" args="()" -->
static int&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetTraceMode</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5d1ab75561cb15368f5b4881dd26e676"></a><!-- doxytag: member="Bp::BpInterconnect::DebugTrace" ref="5d1ab75561cb15368f5b4881dd26e676" args="(const char *formatString,...)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>DebugTrace</b> (const char *formatString,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4a5b4929003e31b40865c9a004f3b41a"></a><!-- doxytag: member="Bp::BpInterconnect::ErrorMsg" ref="4a5b4929003e31b40865c9a004f3b41a" args="(const char *formatString,...)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ErrorMsg</b> (const char *formatString,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="96fce4665457032d13eace00ad9a65be"></a><!-- doxytag: member="Bp::BpInterconnect::WarningMsg" ref="96fce4665457032d13eace00ad9a65be" args="(const char *formatString,...)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>WarningMsg</b> (const char *formatString,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4ab92cc121feba3b92b1d42d5317b0a9"></a><!-- doxytag: member="Bp::BpInterconnect::GetUnregisteredTypeId" ref="4ab92cc121feba3b92b1d42d5317b0a9" args="(const string &amp;typeName)" -->
static uvm_ml_type_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetUnregisteredTypeId</b> (const string &amp;typeName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60ad5029407b89dd95593cfdb63cb4cc"></a><!-- doxytag: member="Bp::BpInterconnect::FindUnregisteredTypeName" ref="60ad5029407b89dd95593cfdb63cb4cc" args="(uvm_ml_type_id_t typeId)" -->
static const string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>FindUnregisteredTypeName</b> (uvm_ml_type_id_t typeId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c62fa92d4dc5d73137574df6b4dae2b"></a><!-- doxytag: member="Bp::BpInterconnect::AddRegisteredTypeEntry" ref="0c62fa92d4dc5d73137574df6b4dae2b" args="(BpTypeMapEntryClass *entry)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddRegisteredTypeEntry</b> (BpTypeMapEntryClass *entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d734a0168a734aa933e516bf0d8ee27"></a><!-- doxytag: member="Bp::BpInterconnect::GetNextTypeId" ref="8d734a0168a734aa933e516bf0d8ee27" args="()" -->
static uvm_ml_type_id_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetNextTypeId</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d1d9edcbb3418503995a00d6da01936f"></a><!-- doxytag: member="Bp::BpInterconnect::GetSingleProvider" ref="d1d9edcbb3418503995a00d6da01936f" args="(int frameworkId, int producerBindKey)" -->
static BpConnectionClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSingleProvider</b> (int frameworkId, int producerBindKey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="75c00ec0371561746cd01927c940175c"></a><!-- doxytag: member="Bp::BpInterconnect::GetSingleProducer" ref="75c00ec0371561746cd01927c940175c" args="(int frameworkId, int providerBindKey)" -->
static BpConnectionClass *&nbsp;</td><td class="memItemRight" valign="bottom"><b>GetSingleProducer</b> (int frameworkId, int providerBindKey)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="3a7a80ee1365a74fd3611c69b72587b3"></a><!-- doxytag: member="Bp::BpInterconnect::FrameworksCompatibleBlocking" ref="3a7a80ee1365a74fd3611c69b72587b3" args="(FrameworkProxyClass &amp;frmw1, FrameworkProxyClass &amp;frmw2)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>FrameworksCompatibleBlocking</b> (FrameworkProxyClass &amp;frmw1, FrameworkProxyClass &amp;frmw2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8246ac88e1eb89f1cbeecd2c6e0f6b28"></a><!-- doxytag: member="Bp::BpInterconnect::ParseArgument" ref="8246ac88e1eb89f1cbeecd2c6e0f6b28" args="(const string &amp;arg, string &amp;frameworkIndicator, string &amp;compIdentifier, string &amp;instanceName)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ParseArgument</b> (const string &amp;arg, string &amp;frameworkIndicator, string &amp;compIdentifier, string &amp;instanceName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ff0d6613bfdb6c46c74bff8b80e12f8"></a><!-- doxytag: member="Bp::BpInterconnect::ParseTypeName" ref="9ff0d6613bfdb6c46c74bff8b80e12f8" args="(const string &amp;arg, string &amp;frameworkIndicator, string &amp;typeName)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>ParseTypeName</b> (const string &amp;arg, string &amp;frameworkIndicator, string &amp;typeName)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8faf2f2a04599f99799b274c9a9af20b"></a><!-- doxytag: member="Bp::BpInterconnect::AddFrmwIndicator" ref="8faf2f2a04599f99799b274c9a9af20b" args="(const string &amp;indicator, FrameworkProxyClass *frmw)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AddFrmwIndicator</b> (const string &amp;indicator, FrameworkProxyClass *frmw)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="45df64542775d21bc75815ed8bc3b1db"></a><!-- doxytag: member="Bp::BpInterconnect::SERROR" ref="45df64542775d21bc75815ed8bc3b1db" args="(int msgId, const string &amp;msg)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SERROR</b> (int msgId, const string &amp;msg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="971065f9babf4469bdf3e3446d07b1e0"></a><!-- doxytag: member="Bp::BpInterconnect::SERROR2" ref="971065f9babf4469bdf3e3446d07b1e0" args="(int msgId, const char *fmt, const string &amp;msg, const string &amp;msg1)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SERROR2</b> (int msgId, const char *fmt, const string &amp;msg, const string &amp;msg1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f7c118c58ae03db31304a7eb1d6d1047"></a><!-- doxytag: member="Bp::BpInterconnect::SERROR3" ref="f7c118c58ae03db31304a7eb1d6d1047" args="(int msgId, const char *fmt, const string &amp;msg, const string &amp;msg1, const string &amp;msg2)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><b>SERROR3</b> (int msgId, const char *fmt, const string &amp;msg, const string &amp;msg1, const string &amp;msg2)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d2fe768ecfc493ebdbb22c61b8dace7c"></a><!-- doxytag: member="Bp::BpInterconnect::m_debug_requests" ref="d2fe768ecfc493ebdbb22c61b8dace7c" args="" -->
static <a class="el" href="classBp_1_1BpInterconnect_1_1BpStopRequestClass.html">BpStopRequestClass</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#d2fe768ecfc493ebdbb22c61b8dace7c">m_debug_requests</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e58388011a09500455ccc8c55ad5eaa4"></a><!-- doxytag: member="Bp::BpInterconnect::m_current_phase_name" ref="e58388011a09500455ccc8c55ad5eaa4" args="" -->
static string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#e58388011a09500455ccc8c55ad5eaa4">m_current_phase_name</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2e670879ea1b9c669b66b1274b97351f"></a><!-- doxytag: member="Bp::BpInterconnect::m_first_phase" ref="2e670879ea1b9c669b66b1274b97351f" args="" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#2e670879ea1b9c669b66b1274b97351f">m_first_phase</a></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9e81d72000111046dd680310eb928387"></a><!-- doxytag: member="Bp::BpInterconnect::BpInterconnect" ref="9e81d72000111046dd680310eb928387" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#9e81d72000111046dd680310eb928387">BpInterconnect</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ea63e7957f0bbf3abadb9a76e545b21"></a><!-- doxytag: member="Bp::BpInterconnect::~BpInterconnect" ref="6ea63e7957f0bbf3abadb9a76e545b21" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect.html#6ea63e7957f0bbf3abadb9a76e545b21">~BpInterconnect</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandBase.html">BpCommandBase</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Abstract base interfaces,.  <a href="classBp_1_1BpInterconnect_1_1BpCommandBase.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandOptionsBase.html">BpCommandOptionsBase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandPhase.html">BpCommandPhase</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandPrintConnections.html">BpCommandPrintConnections</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandPrintTree.html">BpCommandPrintTree</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCommandTraceRegister.html">BpCommandTraceRegister</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpCustomCommand.html">BpCustomCommand</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpDebugClass.html">BpDebugClass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpExternalCommand.html">BpExternalCommand</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpInternalCommand.html">BpInternalCommand</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpPhaseCommandOptions.html">BpPhaseCommandOptions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpPredefinedCommand.html">BpPredefinedCommand</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpPrintConnectionsCommandOptions.html">BpPrintConnectionsCommandOptions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpPrintTreeCommandOptions.html">BpPrintTreeCommandOptions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpStopRequestClass.html">BpStopRequestClass</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1BpTraceRegisterCommandOptions.html">BpTraceRegisterCommandOptions</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1OptionsDescriptor.html">OptionsDescriptor</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBp_1_1BpInterconnect_1_1OptionsDescriptorBase.html">OptionsDescriptorBase</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Enclosure class for backplane interface and global state. 
<p>
This class represents a singleton definition and contains only static members. It processes requests coming via the Backplane Provide API, stores the ML hierarchy and connectivity information and re-directs the calls to the relevant frameworks. 
<p>

<p>
Definition at line <a class="el" href="bp__interconnect_8h-source.html#l00077">77</a> of file <a class="el" href="bp__interconnect_8h-source.html">bp_interconnect.h</a>.<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="86e816f5e8f45946215871bebcf11256"></a><!-- doxytag: member="Bp::BpInterconnect::AddRootNode" ref="86e816f5e8f45946215871bebcf11256" args="(int frameworkId, int topComponentId, const string &amp;compIdentifier, const string &amp;instanceName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::AddRootNode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>topComponentId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>compIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>instanceName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows a framework to add a root node descriptor procedurally. 
<p>
(rather than as an argument of bp_run_test() or <a class="el" href="classBp_1_1BpInterconnect.html#ff112b66cfc310875bad2d0344813aee">Bootstrap()</a>)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>topComponentId</em>&nbsp;</td><td>- the root node id, unique for this framework only </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>compIdentifier</em>&nbsp;</td><td>- the root node identifier string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceName</em>&nbsp;</td><td>- the root node instance name (to be used in a full hierarchical name)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The returns the following codes:<ul>
<li>1 : if the root node was added</li><li>0 : if it was already registered before</li><li>(-1) : upon an error (if another root node was registered with the same instance name) </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ff112b66cfc310875bad2d0344813aee"></a><!-- doxytag: member="Bp::BpInterconnect::Bootstrap" ref="ff112b66cfc310875bad2d0344813aee" args="(vector&lt; string &gt; &amp;tops, vector&lt; string &gt; &amp;tests, bp_serror_t *serror)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bp_api_struct* Bp::BpInterconnect::Bootstrap           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tests</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bp_serror_t *&nbsp;</td>
          <td class="paramname"> <em>serror</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke phasing. 
<p>
Is an optional method that can be invoked directly by a master simulator to start the phasing. This is an alternative mechanism to explicit phasing initialization by the user(via the Provided API function bp_run_test). This method allows to pass extra parameters, unsupported by bp_run_test().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>preInitial</em>&nbsp;</td><td>- a function pointer that can be used to register a phasing start callback. If used, it allows to execute the phasing before execution of any user-defined inital blocks, processes, threads, etc. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tops</em>&nbsp;</td><td>- see <a class="el" href="classBp_1_1BpInterconnect.html#5442d2afe6ba570957a6a768da4c36ea">ProcessTopsAndTests()</a> description above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tests</em>&nbsp;</td><td>- see <a class="el" href="classBp_1_1BpInterconnect.html#5442d2afe6ba570957a6a768da4c36ea">ProcessTopsAndTests()</a> description above </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>serror</em>&nbsp;</td><td>- an optional function pointer that can be provided by a master simulator so that the simulator's messaging mechanism can be used directly.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the following :<ul>
<li>if successful : the provided API function pointer array (tray)</li><li>0 : upon an error </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="4af9693692b531997648841cd5eba4a5"></a><!-- doxytag: member="Bp::BpInterconnect::BTransportTLM2Response" ref="4af9693692b531997648841cd5eba4a5" args="(int frameworkId, int initiatorBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t &amp;stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::BTransportTLM2Response           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initiatorBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawned blocking call completion. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>0 if the task was disabled </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f06f00ddfd0bdd3c96556fdd5cb76f1"></a><!-- doxytag: member="Bp::BpInterconnect::CanGet" ref="0f06f00ddfd0bdd3c96556fdd5cb76f1" args="(int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::CanGet           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking get interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="330f230f504756c5353be3a88501b660"></a><!-- doxytag: member="Bp::BpInterconnect::CanPeek" ref="330f230f504756c5353be3a88501b660" args="(int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::CanPeek           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking peek interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="d0bca5a8412b9d6467113b0e72f9a847"></a><!-- doxytag: member="Bp::BpInterconnect::CanPut" ref="d0bca5a8412b9d6467113b0e72f9a847" args="(int frameworkId, int producerBindKey, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::CanPut           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking put interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb210ebda40f9eb04d13fb72dfc9daec"></a><!-- doxytag: member="Bp::BpInterconnect::Elaborate" ref="fb210ebda40f9eb04d13fb72dfc9daec" args="(void *cbInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::Elaborate           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbInfo</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Invoke phasing. 
<p>
This optional function may be invoked by a master simulator (e.g. as a pre-initial callback function) to launch the pre-run phases<p>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the following :<ul>
<li>1 : upon success</li><li>0 : if there was an elaboration time error </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="87f86ef3d44ae44ee5c38a8467b85eb8"></a><!-- doxytag: member="Bp::BpInterconnect::Get" ref="87f86ef3d44ae44ee5c38a8467b85eb8" args="(int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::Get           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit &amp;&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 blocking get interface method. 
<p>
This native blocking call is not supported The pseudo-blocking mechanism of <a class="el" href="classBp_1_1BpInterconnect.html#47b37a8d9b90c62b180fbf780297db0d">RequestGet()</a>/NotifyEndTask() shpild be used instead 
</div>
</div><p>
<a class="anchor" name="bfa65d55a25db03108e3bf13d91a5a15"></a><!-- doxytag: member="Bp::BpInterconnect::GetProvidedTray" ref="bfa65d55a25db03108e3bf13d91a5a15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bp_api_struct* Bp::BpInterconnect::GetProvidedTray           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns tray of Backplane provider API function pointers. 
<p>
<a class="el" href="classBp_1_1BpInterconnect.html#bfa65d55a25db03108e3bf13d91a5a15">GetProvidedTray()</a> shall be invoked first in order to obtain an access to BP Provided API 
</div>
</div><p>
<a class="anchor" name="d1dffcc4594cea347254159a5746f651"></a><!-- doxytag: member="Bp::BpInterconnect::GetRequested" ref="d1dffcc4594cea347254159a5746f651" args="(int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int Bp::BpInterconnect::GetRequested           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Part of the pseudo-blocking mechanism for implementation of the TLM1 blocking. 
<p>
get interface method. This method shall be invoked by the producer framework's ML adapter after the thread spawned by Requestget() completes and the provider framework ML adapter notifies the producer via NotifyEndTask().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requestId</em>&nbsp;</td><td>- a unique id, assigned to this call by the producer framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- container for returned serialized transaction data stream. It can be filled in this method only if the provider's get() implementation method returns immediately, without blocking</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Output stream size </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc4b8ab12531b9a8b97c22600662d5de"></a><!-- doxytag: member="Bp::BpInterconnect::GetTypeIdByTypeName" ref="fc4b8ab12531b9a8b97c22600662d5de" args="(int frameworkId, const string &amp;typeName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uvm_ml_type_id_t Bp::BpInterconnect::GetTypeIdByTypeName           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>typeName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
May be used for transaction runtime type identification. 
<p>
Assuming that the connected frameworks support passing polymorphic transactions across the same TLM port/socket, the connected frameworks shall map the corresponding type names and obtain the unique type id from the bp. By default, the corresponding types are matched by name. Once the type id is obtained, it shall be included by the producer/initiator in the transaction meta data and the provider/target shall use the id to construct the correct object. 
</div>
</div><p>
<a class="anchor" name="d5158c06f5316c53085b813f8ca55522"></a><!-- doxytag: member="Bp::BpInterconnect::GetTypeNameByTypeId" ref="d5158c06f5316c53085b813f8ca55522" args="(int frameworkId, uvm_ml_type_id_t typeId, bool GetBaseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const string&amp; Bp::BpInterconnect::GetTypeNameByTypeId           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_type_id_t&nbsp;</td>
          <td class="paramname"> <em>typeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>GetBaseName</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
May be used by a framework if it supports passing polymorphic. 
<p>
transactions and needs a class name in order to construct the corresponding object on the provider/target side. 
</div>
</div><p>
<a class="anchor" name="a55e8faa9b6907f92b1d863a2e1b2fb3"></a><!-- doxytag: member="Bp::BpInterconnect::GetVersion" ref="a55e8faa9b6907f92b1d863a2e1b2fb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static const string&amp; Bp::BpInterconnect::GetVersion           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the UVM-ML version. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>The current UVM-ML version </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e084631ca45d91e9d9ed972338dc1d6"></a><!-- doxytag: member="Bp::BpInterconnect::NbGet" ref="1e084631ca45d91e9d9ed972338dc1d6" args="(int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::NbGet           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking get interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- return value: size (in words) of the serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- transaction data stream container to be filled by the export/imp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="3880f3b289d789e2721e3ddc95303e37"></a><!-- doxytag: member="Bp::BpInterconnect::NbPeek" ref="3880f3b289d789e2721e3ddc95303e37" args="(int frameworkId, int producerBindKey, unsigned int &amp;streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::NbPeek           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking peek interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- return value: size (in words) of the serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- transaction data stream container to be filled by the export/imp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="f21b84dfffaa4bfe9f265ded28cc3027"></a><!-- doxytag: member="Bp::BpInterconnect::NbPut" ref="f21b84dfffaa4bfe9f265ded28cc3027" args="(int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::NbPut           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 non-blocking put interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- size (in words) of the serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The value returned by the export (imp) </dd></dl>

</div>
</div><p>
<a class="anchor" name="9353d623ea0069e26179ef927dfac4b8"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyPhase" ref="9353d623ea0069e26179ef927dfac4b8" args="(unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::NotifyPhase           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_phase_action&nbsp;</td>
          <td class="paramname"> <em>phaseAction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies the framework of a non-runtime phase (non-time consuming). 
<p>
Called by the master phase controller to notify a phase has started, is executing, is ready to end or has ended. (from child to parent).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- In the case of broadcasting, it's the unique ID of the master phase controller's framework adapter. In the case where the notification is to a particular component (targetId &gt;= 0), it's the framework ID of the target component. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseGroup</em>&nbsp;</td><td>- Name of the group the phase belongs in (eg. common, uvm ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseAction</em>&nbsp;</td><td>- The action for this phase (start, execute, ready to end, ended)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Return status<ul>
<li>1 : success</li><li>0 : error </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="0600b8bfdffd679657d4e2600b51edb4"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyPhaseDone" ref="0600b8bfdffd679657d4e2600b51edb4" args="(unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::NotifyPhaseDone           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies the phase master that the framework is ready to exit the phase. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- Unique ID of the framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseGroup</em>&nbsp;</td><td>- Name of the group the phase belongs in (eg. common, uvm ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- Current simulation time unit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- Current simulatin time scaled according to time_unit </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c1607df6b1ea36d19b27ca0533a661ae"></a><!-- doxytag: member="Bp::BpInterconnect::NotifyRuntimePhase" ref="c1607df6b1ea36d19b27ca0533a661ae" args="(unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction, uvm_ml_time_unit timeUnit, double timeValue, unsigned int *participate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::NotifyRuntimePhase           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_phase_action&nbsp;</td>
          <td class="paramname"> <em>phaseAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>participate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies the execution of a runtime phase. A phase that consumes time. 
<p>
Called by the master phase controller to notify a runtime phase is executing. Unlike non-runtime phases which could execute either topdown or bottom-up, a runtime phase is executed 'in parallel'. The <a class="el" href="classBp_1_1BpInterconnect.html">BpInterconnect</a> will broadcast the phase to all framework only once, regardless of how many toplevel components the framework contains. The framework should phase all its' toplevel component at the same time. A framework could choose to participate in phase synchronization (controlling when the phase will end) by asserting the participate variable. The <a class="el" href="classBp_1_1BpInterconnect.html">BpInterconnect</a> will sum up the number of participating frameworks and pass the value back to the master phase controller. The framework notifies the phase master that it's ready to exit the phase by calling bp_notify_phase_done(). The master phase controller will wait until all participating frameworks are ready to exit the phase before continuing on to the next phase.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- Unique ID of the framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseGroup</em>&nbsp;</td><td>- Name of the group the phase belongs in (eg. common, uvm ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseAction</em>&nbsp;</td><td>- The action for this phase (start, execute, ready to end, ended) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- Current simulation time unit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- Current simulatin time scaled according to timeUnit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>participate</em>&nbsp;</td><td>- Indicates the number of frameworks participating in the phase</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Return status<ul>
<li>1 : success</li><li>0 : error </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="16e05da4e59f41d1cfd68bcd1d5aafdb"></a><!-- doxytag: member="Bp::BpInterconnect::PhaseSrvCheckFuturePhase" ref="16e05da4e59f41d1cfd68bcd1d5aafdb" args="(const char *phaseName, uvm_ml_phase_action phaseAction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::PhaseSrvCheckFuturePhase           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_phase_action&nbsp;</td>
          <td class="paramname"> <em>phaseAction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls the phase service provider to check phase did not pass. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseAction</em>&nbsp;</td><td>- The action for this phase </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Return status<ul>
<li>1 : success</li><li>0 : phase passed already </li></ul>
</dd></dl>

<p>
Referenced by <a class="el" href="bp__debug_8cpp-source.html#l00095">Bp::BpInterconnect::BpStopRequestClass::RequestStopPhase()</a>.
</div>
</div><p>
<a class="anchor" name="8c3ea0928b653830d2457db4d43b3443"></a><!-- doxytag: member="Bp::BpInterconnect::PhaseSrvCheckPhase" ref="8c3ea0928b653830d2457db4d43b3443" args="(const char *phaseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::PhaseSrvCheckPhase           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls the phase service provider to check phase name. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Return status<ul>
<li>1 : success</li><li>0 : phase not supported </li></ul>
</dd></dl>

<p>
Referenced by <a class="el" href="bp__debug_8cpp-source.html#l00088">Bp::BpInterconnect::BpStopRequestClass::CheckPhaseName()</a>, and <a class="el" href="bp__debug_8cpp-source.html#l00095">Bp::BpInterconnect::BpStopRequestClass::RequestStopPhase()</a>.
</div>
</div><p>
<a class="anchor" name="6f42da9e97f65de3ac34b45b84416103"></a><!-- doxytag: member="Bp::BpInterconnect::PhaseSrvNotifyPhaseDone" ref="6f42da9e97f65de3ac34b45b84416103" args="(unsigned int frameworkId, const char *phaseGroup, const char *phaseName, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::PhaseSrvNotifyPhaseDone           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calls the phase service provider to notify the framework is ready. 
<p>
to exit the phase.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- Unique ID of the framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseGroup</em>&nbsp;</td><td>- Name of the group the phase belongs in (eg. common, uvm ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- Current simulation time unit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- Current simulatin time scaled according to time_unit </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="773867f3d030d254ba3d522027b512d8"></a><!-- doxytag: member="Bp::BpInterconnect::PreRunCleanup" ref="773867f3d030d254ba3d522027b512d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::PreRunCleanup           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cleanup Backplane global state. 
<p>
This function resets the global state to the state that was prior to run_test 
</div>
</div><p>
<a class="anchor" name="5442d2afe6ba570957a6a768da4c36ea"></a><!-- doxytag: member="Bp::BpInterconnect::ProcessTopsAndTests" ref="5442d2afe6ba570957a6a768da4c36ea" args="(vector&lt; string &gt; &amp;tops, vector&lt; string &gt; &amp;tests)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::ProcessTopsAndTests           </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>tests</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Process vector of strings that denotes top components/tests in TB. 
<p>
Processes string arguments that denote ML hierarchy root nodes (components) and stores parsed values till the start of phasing.<p>
UVM-ML supports multiple root nodes<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tops</em>&nbsp;</td><td>- a vector of strings, one per ML root node. Each top argument shall follow the following pattern: &lt;Framework-indicator&gt;:&lt;Root-node-identifier&gt;[:&lt;Instance-name] if instance-name is not specifies the root-node-identifier is duplicated as the instance name as well </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tests</em>&nbsp;</td><td>- a vector of strings, one per ML test identifier. A test is a root node with a predefined instance name (m_test_instance_name) BP checks that not more than one test is specified. BP issues an error if tests.size() &gt; 1 </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="710d0f12abd91a767dd8dc5cfa9eb8ac"></a><!-- doxytag: member="Bp::BpInterconnect::Put" ref="710d0f12abd91a767dd8dc5cfa9eb8ac" args="(int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::Put           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit &amp;&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM1 blocking put interface method. 
<p>
This native blocking call is not supported The pseudo-blocking mechanism of <a class="el" href="classBp_1_1BpInterconnect.html#b86bb5db30aa4fe4e1011bce9b7c067f">RequestPut()</a>/NotifyEndTask() shpild be used instead 
</div>
</div><p>
<a class="anchor" name="6ab9c0993afbbb612d29976b8ad78dcc"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterCommonSrvFrmw" ref="6ab9c0993afbbb612d29976b8ad78dcc" args="(FrameworkProxyClass *frmw)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::RegisterCommonSrvFrmw           </td>
          <td>(</td>
          <td class="paramtype">FrameworkProxyClass *&nbsp;</td>
          <td class="paramname"> <em>frmw</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register common service framework with backplane. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frmw</em>&nbsp;</td><td>- Pointer to frameworkProxy </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="09f290296954e68459115db1cbb152da"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterFramework" ref="09f290296954e68459115db1cbb152da" args="(const string &amp;frameworkName, vector&lt; string &gt; &amp;frameworkIndicators, bp_frmw_c_api_struct *requiredApi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::RegisterFramework           </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>frameworkName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>frameworkIndicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bp_frmw_c_api_struct *&nbsp;</td>
          <td class="paramname"> <em>requiredApi</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a framework with the backplane. 
<p>
Shall be invoked via the BP Provided API by each participating framework. It creates an internal framework proxy object in BP framework registry.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkName</em>&nbsp;</td><td>- A voluntary string (ideally it shall be unique foreeach framework. This string is used only for tracing</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frameworkIndicators</em>&nbsp;</td><td>- each framework shall be associated with one or more short string names (indicators). These indicators are used by the integrator to denote the framework</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requiredApi</em>&nbsp;</td><td>- a C function pointer array (BP Required API tray)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>If successful - allocates and returns a unique FrameworkId (-1) - in case of an error </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb4a0bd3c8555ea95b426a01af9ce7c6"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterRoute" ref="eb4a0bd3c8555ea95b426a01af9ce7c6" args="(int frameworkId, const string &amp;producerPath, const string &amp;providerPath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Bp::BpInterconnect::RegisterRoute           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>producerPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>providerPath</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shall be invoked by a framework to connect ML TLM ports or sockets. 
<p>
(e.g. port&lt;-&gt;export, initiator_socket&lt;-&gt;target_socket)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerPath</em>&nbsp;</td><td>- the full hierarchical name of a TLM1 port/export or TLM2 initiator socket </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>providerPath</em>&nbsp;</td><td>- the full hierarchical name of a TLM1 export/imp or TLM2 target socket</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns true upon success </dd></dl>

</div>
</div><p>
<a class="anchor" name="b80b1f86d35fdf32d002e0efa074e9d7"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterSrvProviders" ref="b80b1f86d35fdf32d002e0efa074e9d7" args="(unsigned int frameworkId, bp_srv_provider_struct *srvProviders)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::RegisterSrvProviders           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bp_srv_provider_struct *&nbsp;</td>
          <td class="paramname"> <em>srvProviders</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register service providers with the backplane. 
<p>
Indicates to the backplane which services are being provided by which framework. Could be call from the framework or the the user TB code. All srv variables need not be filled. Empty strings will be ignored. If the same service is set multiple times, the last setting will be used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- Unique ID of the framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srvProviders</em>&nbsp;</td><td>- A struct containing variables of type char * of all available services. Each variable specifies the name of the framework providing that service. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20fba6aa51e5440ad3b6c8c8065d81a0"></a><!-- doxytag: member="Bp::BpInterconnect::RegisterTypeMatch" ref="20fba6aa51e5440ad3b6c8c8065d81a0" args="(BpLangTypeName &amp;type1, BpLangTypeName &amp;type2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool Bp::BpInterconnect::RegisterTypeMatch           </td>
          <td>(</td>
          <td class="paramtype">BpLangTypeName &amp;&nbsp;</td>
          <td class="paramname"> <em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BpLangTypeName &amp;&nbsp;</td>
          <td class="paramname"> <em>type2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows explicit type mapping (default mapping is by the exact. 
<p>
type names match 
</div>
</div><p>
<a class="anchor" name="47b37a8d9b90c62b180fbf780297db0d"></a><!-- doxytag: member="Bp::BpInterconnect::RequestGet" ref="47b37a8d9b90c62b180fbf780297db0d" args="(int frameworkId, int producerBindKey, int requestId, unsigned int &amp;streamSize, uvm_ml_stream_t stream, bool &amp;done, uvm_ml_time_unit &amp;timeUnit, double &amp;timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::RequestGet           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit &amp;&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Part of the pseudo-blocking mechanism for implementation of the TLM1 blocking. 
<p>
get interface method. This method spawns a thread (forks off a process) that can block through the framework adapter. When the process terminates the provider adapter invokes NotifyEndTask() and notifies the producer adapter that the method completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requestId</em>&nbsp;</td><td>- a unique id, assigned to this call by the producer framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- size (in words) of the returned serialized transaction data stream. The size value can be returned by this method only if the provider's get() implementation method returns immediately, without blocking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- container for returned serialized transaction data stream. It can be filled in this method only if the provider's get() implementation method returns immediately, without blocking </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>- an output parameter; the provider adapter shall assign it true if the call was completed immediately (did not block) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the following:<ul>
<li>0 : if the blocking calls completes normally</li><li>1 : if the corresponding thread was disabled before normal completion </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="b86bb5db30aa4fe4e1011bce9b7c067f"></a><!-- doxytag: member="Bp::BpInterconnect::RequestPut" ref="b86bb5db30aa4fe4e1011bce9b7c067f" args="(int frameworkId, int producerBindKey, int requestId, unsigned int streamSize, uvm_ml_stream_t stream, bool &amp;done, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::RequestPut           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>done</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM! blocking put interface pseudo method. 
<p>
Part of the pseudo-blocking mechanism for implementation of the TLM1 blocking put interface method. This method spawns a thread (forks off a process) that can block through a framework adapter. When the process terminates the provider adapter invokes NotifyEndTask() and notifies the producer adapter that the method completed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>requestId</em>&nbsp;</td><td>- a unique id, assigned to this call by the producer framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- size (in words) of the serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>done</em>&nbsp;</td><td>- an output parameter; the provider adapter shall assign it true if the call was completed immediately (did not block) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the following:<ul>
<li>0 : if the blocking calls completes normally</li><li>1 : if the corresponding thread was disabled before normal completion </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c8730ce724663bb6f9904e87c6a1f72f"></a><!-- doxytag: member="Bp::BpInterconnect::Reset" ref="c8730ce724663bb6f9904e87c6a1f72f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::Reset           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reset Backplane global state. 
<p>
This function resets the global state in response to the simulator reset event 
</div>
</div><p>
<a class="anchor" name="a7393c82ea705f1d1bf9f56a92dde722"></a><!-- doxytag: member="Bp::BpInterconnect::SetTraceMode" ref="a7393c82ea705f1d1bf9f56a92dde722" args="(int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::SetTraceMode           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Turn tracing on/off. 
<p>
Each framework can invoke <a class="el" href="classBp_1_1BpInterconnect.html#a7393c82ea705f1d1bf9f56a92dde722">SetTraceMode()</a> and BP broadcasts this request to turn on/off the UVM ML activities tracing 
</div>
</div><p>
<a class="anchor" name="bcf6757f3ee45264aa241df3f579e592"></a><!-- doxytag: member="Bp::BpInterconnect::TransmitPhase" ref="bcf6757f3ee45264aa241df3f579e592" args="(unsigned int frameworkId, const string &amp;targetFrmwInd, int targetId, const char *phaseGroup, const char *phaseName, uvm_ml_phase_action phaseAction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::TransmitPhase           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&nbsp;</td>
          <td class="paramname"> <em>targetFrmwInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>targetId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseGroup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>phaseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_phase_action&nbsp;</td>
          <td class="paramname"> <em>phaseAction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notifies a target component of a non_runtime phase (non-time conssuming). 
<p>
Called by the backplane or child proxy to notify a phase.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- Unique ID of the framework adapter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetFrmwInd</em>&nbsp;</td><td>- Framework indicator for the target </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>targetId</em>&nbsp;</td><td>- The ID of the target. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseGroup</em>&nbsp;</td><td>- Name of the group the phase belongs in (eg. common, uvm ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseName</em>&nbsp;</td><td>- Name of the phase </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phaseAction</em>&nbsp;</td><td>- The action for this phase (start, execute, ready to end, ended)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Return status<ul>
<li>1 : success</li><li>0 : error </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="3227dbbb0974eb699a49f89ba3820529"></a><!-- doxytag: member="Bp::BpInterconnect::TransportTLM1Response" ref="3227dbbb0974eb699a49f89ba3820529" args="(int frameworkId, int producerBindKey, int requestId, uvm_ml_stream_t &amp;respStream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int Bp::BpInterconnect::TransportTLM1Response           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>requestId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t &amp;&nbsp;</td>
          <td class="paramname"> <em>respStream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spawned blocking call completion. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>RespStreamSize - response stream size </dd></dl>

</div>
</div><p>
<a class="anchor" name="2060b6637b885cfea3d9bc0f78664fa3"></a><!-- doxytag: member="Bp::BpInterconnect::Write" ref="2060b6637b885cfea3d9bc0f78664fa3" args="(int frameworkId, int producerBindKey, unsigned int streamSize, uvm_ml_stream_t stream, uvm_ml_time_unit timeUnit, double timeValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Bp::BpInterconnect::Write           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>frameworkId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>producerBindKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>streamSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_stream_t&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uvm_ml_time_unit&nbsp;</td>
          <td class="paramname"> <em>timeUnit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>timeValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
TLM analysis interface method. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>frameworkId</em>&nbsp;</td><td>- the unique id previously allocated by RegisterFramework </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>producerBindKey</em>&nbsp;</td><td>- a connection id on the producer's framework adapter side </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>streamSize</em>&nbsp;</td><td>- size (in words) of the serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>- serialized transaction data stream </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeUnit</em>&nbsp;</td><td>- current simulation time units enum (TIME_UNIT_UNDEFINED if the framework does not have an ability to advance time) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeValue</em>&nbsp;</td><td>- numeric value of current simulation time scaled according to timeUnit </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>backplane/<a class="el" href="bp__interconnect_8h-source.html">bp_interconnect.h</a><li>backplane/<a class="el" href="bp__debug_8cpp-source.html">bp_debug.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Sun Aug 23 11:20:56 2015 for UVM-ML by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
