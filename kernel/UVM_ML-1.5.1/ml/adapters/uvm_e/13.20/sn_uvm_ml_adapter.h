//----------------------------------------------------------------------
//   Copyright 2012 Cadence Design Systems, Inc.
//   Copyright 2012-2013 Advanced Micro Devices Inc.
//   All Rights Reserved Worldwide
//
//   Licensed under the Apache License, Version 2.0 (the
//   "License"); you may not use this file except in
//   compliance with the License.  You may obtain a copy of
//   the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in
//   writing, software distributed under the License is
//   distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
//   CONDITIONS OF ANY KIND, either express or implied.  See
//   the License for the specific language governing
//   permissions and limitations under the License.
//----------------------------------------------------------------------


#ifndef SN_UVM_ML_ADAPTER_H
#define SN_UVM_ML_ADAPTER_H

#include "bp_provided.h" 
#include "sn_uvm_ml_h.h" /* generated by sn_compile.sh for uvm-ml */

#define SN_UVM_ML_VERSION "1.5.1"
#define SN_ADAPTER_NAME "UVM_ML"

/*                            */
/* Specman to Backplane calls */
/*                            */

SN_TYPE(bool) sn_register_uvm_ml_adapter();
int ml_sn_get_adapter_id();
int ml_sn_get_debug_mode();
SN_TYPE(bool) ml_sn_reset_actions(SN_TYPE(bool) specman_only);
SN_TYPE(bool) ml_sn_has_get_pack_max_size_symbol();
int ml_sn_get_pack_max_size();
void ml_sn_set_pack_max_size(int size);
unsigned int ml_sn_assign_transaction_id();
unsigned int ml_sn_get_type_id_from_name(char * type_name);
SN_TYPE(string) ml_sn_get_type_name_from_id(unsigned int type_id);
unsigned ml_sn_connect_names(SN_TYPE(string) path1,
			     SN_TYPE(string) path2);
SN_TYPE(bool) ml_sn_can_get(unsigned int connector_id);
SN_TYPE(bool) ml_sn_try_get_bitstream(unsigned int connector_id,
				      unsigned int * clist_size,
				      void * clist0);
SN_TYPE(bool) ml_sn_can_peek(unsigned int connector_id);
SN_TYPE(bool) ml_sn_try_peek_bitstream(unsigned int connector_id,
				       unsigned int * clist_size,
				       void * clist0);
SN_TYPE(bool) ml_sn_can_put(unsigned int connector_id);
SN_TYPE(bool) ml_sn_try_put_bitstream(unsigned int connector_id,
				      unsigned int clist_size,
				      void * clist);
void ml_sn_write_bitstream(unsigned int connector_id,
			   unsigned int clist_size,
			   void * clist);
void ml_sn_get_bitstream_request(unsigned int port_id,
				 unsigned int call_id,
				 unsigned int * clist_size,
				 void * clist,
				 int * done);
unsigned int ml_sn_get_requested_bitstream(unsigned int port_id,
					   unsigned int call_id,
					   void * stream);
void ml_sn_peek_bitstream_request(unsigned int port_id,
				  unsigned int call_id,
				  unsigned int * clist_size,
				  void * clist,
				  int * done);
unsigned int ml_sn_peek_requested_bitstream(unsigned int port_id,
					    unsigned int call_id,
					    void * stream);
void ml_sn_put_bitstream_request(unsigned int port_id,
				 unsigned int call_id,
				 unsigned int clist_size,
				 void * clist,
				 int * done);
SN_TYPE(bool) ml_sn_nb_transport_bitstream(unsigned int port_id,
					   unsigned int req_clist_size,
					   void * req_clist,
					   unsigned int * rsp_clist_size,
					   void * rsp_clist);
void ml_sn_transport_bitstream_request(unsigned int port_id,
				       unsigned int call_id,
				       unsigned int req_clist_size,
				       void * req_clist,
				       unsigned int * rsp_clist_size,
				       void * rsp_clist,
				       int * done);
unsigned int ml_sn_transport_response_bitstream(unsigned int port_id,
						unsigned int call_id,
						void * stream);
void ml_sn_notify_end_task(unsigned int adapter_cb_id,
			   unsigned int call_id);
int ml_sn_tlm2_b_transport_request(unsigned int initiator_connector_id,
				   unsigned int call_id,
				   unsigned int * stream_size,
				   void ** stream,
				   SN_TYPE(e_time_units) delay_unit, 
				   SN_TYPE(real) delay_value, 
				   SN_TYPE(bool) * done);
int ml_sn_tlm2_b_transport_response(unsigned int initiator_connector_id,
				    unsigned int call_id,
				    unsigned int * stream_size,
				    void * stream);
SN_TYPE(tlm_sync_enum) ml_sn_tlm2_nb_transport_fw(unsigned int initiator_connector_id,
						  unsigned int * stream_size,
						  void ** stream,
						  SN_TYPE(tlm_phase_enum) * phase, 
						  int transaction_id, 
						  SN_TYPE(e_time_units) * delay_unit,
						  void * delay_value);
SN_TYPE(tlm_sync_enum) ml_sn_tlm2_nb_transport_bw(unsigned int initiator_connector_id,
						  unsigned int * stream_size, 
						  void ** stream,
						  SN_TYPE(tlm_phase_enum) * phase,
						  int transaction_id,
						  SN_TYPE(e_time_units) * delay_unit, 
						  void * delay_value);
unsigned int ml_sn_tlm2_transport_dbg(unsigned int initiator_connector_id,
				      unsigned int * stream_size,
				      void ** stream);
void ml_sn_turn_off_transaction_mapping(SN_TYPE(string) socket_name);
void ml_sn_set_debug_mode(int mode);
int ml_sn_get_connector_size(unsigned int connector_id);
void ml_sn_set_match_types(SN_TYPE(string) n1, 
			   SN_TYPE(string) n2, 
			   SN_TYPE(string) n3);
int ml_sn_create_foreign_child(SN_TYPE(string) target_framework_name,
			       SN_TYPE(string) type_name, 
			       SN_TYPE(string) instance_name, 
			       SN_TYPE(string) parent_full_name,
			       int parent_component_id);
int ml_sn_transmit_phase(SN_TYPE(string) phase_name,
			 SN_TYPE(string) phase_group,
			 SN_TYPE(uvm_ml_phase_action) phase_action,
			 SN_TYPE(string) target_framework_name,
			 int child_component_id);
void ml_sn_notify_config(SN_TYPE(string) cntxt,
			 SN_TYPE(string) instance_name,
			 SN_TYPE(string) field_name,
			 unsigned int stream_size,
			 void * stream);
int ml_sn_execute_command(SN_TYPE(string) cmd_with_arguments);

typedef struct node_t {
  char *data;
  struct node_t *next;
} node;

#endif 
